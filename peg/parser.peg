{
    package peg

    import (
        "fmt"
        "parser/ast"
        "github.com/davecgh/go-spew/spew"
    )

    func toNode(exp interface{}) ast.Node {
        if (exp == nil) {
            return toNode(ast.NullExp{});
        }
        return ast.Node{ exp.(ast.Exp) };
    }

    func toNodes(exps []interface{}) []ast.Node {
        a := make([]ast.Node, len(exps));
        for i := 0; i < len(exps); i++ {
            a[i] = toNode(exps[i]);
        }
        return a;
    }
}

PROGRAM =  expressions:EXPRESSIONBLOCK {
    return toNode(expressions), nil
}

EXPRESSIONBLOCK = expressions:EXPRESSION* {
    return ast.ExpBlock{toNodes(expressions.([]interface{}))}, nil;
}

EXPRESSION = TRUELITERAL / FALSELITERAL / IF / RETURN

IF = _ "if" _ "(" check:EXPRESSIONBLOCK ")" _ "{" consequent:EXPRESSIONBLOCK "}" _ alternate:(ELSE)? _ {
    astNode := ast.If{toNode(check), toNode(consequent), toNode(alternate)};
    return astNode, nil
}

ELSE = _ "else" _ "{" alternate:EXPRESSION "}" _ {
    return alternate, nil;
}

RETURN = _ "return" _ expression:EXPRESSION {
    astNode := ast.Return{toNode(expression)};
    return astNode, nil;
}

TRUELITERAL = _ "true" _ {
    return ast.TrueLiteral{true}, nil;
}

FALSELITERAL = _ "false" _ {
    return ast.FalseLiteral{false}, nil;
}

_ ← ( Whitespace / EOL )*

Whitespace ← [ \t\r]
EOL ← '\n'
EOF ← !.