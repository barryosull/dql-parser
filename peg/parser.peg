{
    package peg

    import (
        "fmt"
        "parser/ast"
        "github.com/davecgh/go-spew/spew"
    )

    func exp(astNode interface{}) ast.Exp {
        if (astNode == nil) {
            return exp(ast.NullExp{ast.Ast{"NullExp"}});
        }
        return astNode.(ast.Exp);
    }

    func exps(astNodes []interface{}) []ast.Exp {
        e := make([]ast.Exp, len(astNodes));
        for i := 0; i < len(astNodes); i++ {
            e[i] = exp(astNodes[i]);
        }
        return e;
    }
}

EXPRESSIONBLOCK = expressions:EXPRESSION* {
    return ast.ExpBlock{ast.Ast{"ExpBlock"}, exps(expressions.([]interface{}))}, nil;
}

EXPRESSION = TRUELITERAL / FALSELITERAL / IF / RETURN

IF = _ "if" _ "(" check:EXPRESSIONBLOCK ")" _ "{" consequent:EXPRESSIONBLOCK "}" _ alternate:(ELSE)? _ {
    astNode := ast.If{ast.Ast{"If"}, exp(check), exp(consequent), exp(alternate)};
    return astNode, nil
}

ELSE = _ "else" _ "{" alternate:EXPRESSION "}" _ {
    return alternate, nil;
}

RETURN = _ "return" _ expression:EXPRESSION {
    astNode := ast.Return{ast.Ast{"Return"}, exp(expression)};
    return astNode, nil;
}

TRUELITERAL = _ "true" _ {
    return ast.TrueLiteral{ast.Ast{"TrueLiteral"}, true}, nil;
}

FALSELITERAL = _ "false" _ {
    return ast.FalseLiteral{ast.Ast{"FalseLiteral"}, false}, nil;
}

_ ← ( Whitespace / EOL )*

Whitespace ← [ \t\r]
EOL ← '\n'
EOF ← !.